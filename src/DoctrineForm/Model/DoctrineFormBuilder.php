<?php 

/**
* Use Doctrine's entity to build form specification that will be handled by a form factory
* Optionaly Defines also form attributes/elements with Zend\Form\Annotations and merges the whole
* @TODO : using cache, we just deal with arrayobject that are easty to cache.
* cache validity will only depend on reference entity file modifications 
* 
* This could also be used to generated a whole bunch of entities forms and cache the whole
* As soon as a file describing an entity change, this cache should be regenerated
* could be nice  
*/

namespace DoctrineForm\Model;

use DoctrineForm\Model\DoctrineFormBuilder\Resolver\Attributes as AttributesResolver;
use DoctrineForm\Model\DoctrineFormBuilder\Resolver\Type as TypeResolver;
use DoctrineForm\Model\DoctrineFormBuilder\Resolver\Name as NameResolver;
use DoctrineForm\Model\DoctrineFormBuilder\Resolver\Options as OptionsResolver;
use DoctrineForm\Model\DoctrineFormBuilder\Resolver\Form as FormResolver;
use DoctrineForm\Model\DoctrineFormBuilder\ArrayObjectBuilder as Builder;
use Zend\Stdlib\ArrayUtils;

// Used to take Zend\Form\Annotations in consideration
use Zend\Form\Annotation\AnnotationBuilder;

class DoctrineFormBuilder{

    /**
    * fully qualified entiti class
    * var string
    */
    protected $entityClassName;

    /**
    * \EntityManager
    * var \EntityManager
    */
    protected $em;

    /**
    * Metadatas of an entity generated by Doctrine
    * They are what we are going to use to build the form 
    * var Doctrine\ORM\Mapping\ClassMetadata $doctrineMetadatas
    */
    protected $doctrineMetadatas;

    /**
    * Form specifications as FormFactory expects it to be in order to construct the final form class
    * var Array $formSpecs
    * They are the Product  of this form construction process
    */
    protected $specs;

    /**
     * Resolvers, they are the specialised classes who define form elements properties
     * They implements ResolverInterface
     * They just implements resolve(array metadatas) method and each returns an array
     */
    protected $resolvers;
    
    /**
     * Object that will transform the formConfig array into an ArrayObject usable by Zend\Form\Factory
     * Allow personnal logic to build the base array and attaching a personnal builder to transform the personnal aray into a valid arrayobject for Zend\Form\Factory
     * @var Object 
     */
    protected $arrayObjectBuilder;
    
    /**
    * All is needed is an entity valid class and an entityManager(provided by doctrine)
    */
    public function __construct(\Doctrine\ORM\Mapping\ClassMetadata $doctrineMetadatas=null,Builder $arrayObjectBuilder=null, $entityClass=null, \Doctrine\ORM\EntityManager $entityManager=null){
        if ($doctrineMetadatas !== null){
            $this->setDoctrineMetadatas($doctrineMetadatas);
        }
        
        if($entityManager !== null){
            $this->setEntityManager($entityManager);
        }
        
        if ($entityClass !== null){
            $this->setEntityClassName($entity);
        }

        /**
         * Specs returned to Zend\Form\Factory, like expected ArrayObject 
         */
        $this->specs= new \ArrayObject;
        
        $this->setResolvers(
            array(
                'form'          => new FormResolver,
                'type'          => new TypeResolver,
                'attributes'    => new AttributesResolver,
                'options'       => new OptionsResolver,
                'name'          => new NameResolver,
            )
        );
        
        /**
         * Final ArrayObjectBuilder for Zend\Form\Factory
         */
        if ($arrayObjectBuilder !== null){
            $this->setArrayObjectBuilder($arrayObjectBuilder);
        }else{
            $this->setArrayObjectBuilder(new Builder);            
        }
    }

    /**
    * SEt doctrine's entity manager 
    */
    public function setEntityManager(\Doctrine\ORM\EntityManager $em){
        $this->em = $em;
        return $this;
    }

    /**
    * Return's doctrine's entity manager
    * @return Doctrine\ORM\EntityManager
    */
    public function getEntityManager(){
        return $this->em;
    }

    /**
    * Define's entity that is going to be used for form generation
    * As soon as we set the entity, we set corresponding metadatas 
    */
    public function setEntityClassName($FQCN){
        if (!class_exists($FQCN)){
            throw new Exception("Form Builder: received entity FQCN leads to non existant class. FATAL ERROR");
        }
        
        $this->entityClassName = $FQCN;
        
        $metadataFactory = $this->getEntityManager()->getMetadataFactory();
        $this->setDoctrineMetadatas($metadataFactory->getMetadataFor($this->getEntityClassName()));                    
        
        return $this;
    }

    public function getEntity(){
        return $this->entity;
    }

    public function getEntityClassName(){
        return $this->entityClassName;
    }
    
    public function setDoctrineMetadatas(\Doctrine\ORM\Mapping\ClassMetadata $doctrineMetadatas){
        $this->doctrineMetadatas = $doctrineMetadatas;
        return $this;
    }

    public function getDoctrineMetadata(){
        return $this->doctrineMetadatas;
    }
    
    public function setResolvers(array $resolvers){
        foreach($resolvers as $name=>$resolver){
            $this->addResolver($name,$resolver);
        }
        return $this;
    }
    
    public function getResolvers(){
        return $this->resolvers;
    }
    
    public function addResolver($name,$resolver){
        $this->resolvers[$name] = $resolver;
        return $this;
    }

    public function removeResolver($name){
        if (isset($this->resolvers[$name])){
            unset($this->resolvers[$name]);
        }
        return $this;
    }
    
    public function setArrayObjectBuilder($builder){
        $this->arrayObjectBuilder = $builder;
        return $this;
    }

    public function getArrayObjectBuilder(){
        return $this->arrayObjectBuilder;
    }
    
    /**
     * Construct form specifications (ArrayObject) from entity's Doctrine's annotation
     * By default considers also Zend\form\Annotations within the entity
     * If you provides metadatas here or at instanciation, this can be used as a whole shortcut
     * @param \DoctrineForm\Model\Doctrine\ORM\Mapping\ClassMetadata $doctrineMetadatas
     * 
     * By default, Form Annotations in the entity class (if given) will also be treated in taken into consideration for the form building process
     * @param Boolean $mergeAnnotations
     * @return \Zend\Config\Config
     */
    public function buildFormConfig(Doctrine\ORM\Mapping\ClassMetadata $doctrineMetadatas=null, $mergeAnnotations=true){
        if($doctrineMetadatas!==null){
            $this->setDoctrineMetadatas($doctrineMetadatas);
        }
        
        /**
         * All the registered Resolvers are going to loop over the whole metadatas
         * Each of them will return , for each element, a set of properties
         * All are going to be merged into a reference array
         * This array is then going to be transformed into an arrayobject that Zend\Form\Factory will use to create the final form class
         */
        $formConfig=array();
        $elementsConfig=array();
        
        foreach($this->getResolvers() as $resolverName => $resolverInstance){
            $resolved = $resolverInstance->resolve($this->getDoctrineMetadata());
            if ($resolverName == 'form'){
                $formConfig = $resolved;
            }else{
                $elementsConfig = array_merge_recursive($resolved,$elementsConfig);
            }
        }
        $formConfig['elements'] = $elementsConfig;
        
        if ($mergeAnnotations){
            $annotationForm = ArrayUtils::iteratorToArray($this->getAnnotationForm());

            foreach($annotationForm['elements'] as $num => $element){
                if (isset($element['spec']['name'])){
                    $annotatedElementName=$element['spec']['name'];
                    if (isset($formConfig['elements'][$annotatedElementName])){
                        
                        $doctrinesElement = $formConfig['elements'][$annotatedElementName];
                        $finalElement = array_replace_recursive($doctrinesElement,$element);
                        $formConfig['elements'][$annotatedElementName] = $finalElement;
                    }
                }
            }
        }
        
        /**
         * Now, we have to transform rthis formConfigArray into ArrayObject as expected by Zend\Form\Factory
         * In order to provide A form configuration that can be handled to build a full form class
         */
        return $this->buildArrayObject($formConfig);
    }

    public function getAnnotationForm(){
        $builder=new AnnotationBuilder();
        return $builder->getFormSpecification($this->getEntityClassName());        
    }
    
    public function getForm($entityFQCN=null){
        $this->setEntityClassName($entityFQCN);
        $formFactory = new Factory;
        return $formFactory->createForm($this->buildFormConfig());        
    }
    
    private function buildArrayObject($formConfig){
        return $this->getArrayObjectBuilder()->build($formConfig);
    }
    
}
